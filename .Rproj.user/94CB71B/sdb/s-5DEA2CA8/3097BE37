{
    "collab_server" : "",
    "contents" : "## NDVI - seasonal length and productivity\nlibrary(splancs)\nlibrary(rgeos)\nlibrary(rgdal)\nlibrary(raster)\nlibrary(bbmle)\nlibrary(maptools)\n  data(wrld_simpl)\nsource(\"splitYear.R\")\nsource('~/Dropbox/Apps/getProj.R', chdir = TRUE)\nload(\"NDVI_raster.RData\")\n\n\ntmp1 <- NDVI[[1]]\ntmp2 <- rasterize(spTransform(wrld_simpl, CRS(proj4string(NDVI[[1]]))), tmp1)\narea <- matrix(c(-180, rep(-45, 100), rep(-180, 100),\n                 0, seq(0, 80, length=100), seq(80, 0, length=100)), ncol=2)\nareaSP <- SpatialPolygons(list(Polygons(list(Polygon(area)),ID=1)), proj4string=CRS(proj4string(wrld_simpl)))\nbbox   <- spTransform(areaSP, CRS(proj4string(NDVI[[1]])))\n\ntmp2[] <- 1:length(tmp2[])\nind <- unlist(extract(tmp2, bbox))\n\n## NDVI Date index\nindex <- matrix(as.numeric(unlist(strsplit(names(NDVI), \"_\"))), \n                nrow = length(NDVI), ncol = 2, byrow = T)\n## NDVI coordinates\ncrds  <- coordinates(NDVI[[1]]) \n\n\nout <- matrix(nrow = nrow(crds), ncol = 5)\n\nfor(i in ind) {\n  cat(paste(i, \"\\r    \"))\n  tmp <- data.frame(year  = rep(2007:2012, each = 52),\n                    week = rep(1:52, length(2007:2012)), ndvi = NA)\n  for(n in which(index[,1]==2007)[1]:nrow(index)) {  \n    tmp$ndvi[which(paste(tmp[,1], tmp[,2], sep = \"_\")==names(NDVI)[n])] <- values(NDVI[[n]])[i]\n  }  \n  tmp[,3] <- ifelse(tmp[,3]<(-100), NA, tmp[,3])\n  if(sum(!is.na(tmp$ndvi))>150){\n    tmp2 <- splitYear(tmp$ndvi, tmp$week, tmp$year)\n    tmp3 <- data.frame(week = unlist(lapply(tmp2, function(x) x[,2])),\n                       ndvi = unlist(lapply(tmp2, function(x) x[,4])))\n    # plot(tmp3[,2]~tmp3[,1])\n    ls <- loess(tmp3[,2]~tmp3[,1], span = 0.3)\n    pr <- predict(ls, newdata = 1:52)\n    prtmp <- predict(loess(tmp3[,2]~tmp3[,1], span = 0.7), newdata = 1:52)\n    if(length(which(prtmp>c(prtmp[-1], NA) & prtmp>c(NA, prtmp[-length(prtmp)])))>0){    \n    # lines(1:52, pr, lwd=2, col=\"orange\")\n    \n    tmp4 <- cbind(c(1:52), pr)\n      mx <- max(which(tmp4[,2]>c(tmp4[-1,2], NA) & tmp4[,2]>c(NA, tmp4[-nrow(tmp4),2])))\n      ct01  <- tmp4[min(which(!is.na(tmp4[,2]))):mx,]\n      ind01 <- ct01[which(ct01[,2]<c(NA, ct01[-nrow(ct01),2]) & ct01[,2]<c(ct01[-1,2], NA)),1]\n      if(length(ind01)>0) ct1 <- tmp4[ind01[which.min(tmp4[ind01,2])],1] else ct1 <- min(which(!is.na(pr)))\n    # abline(v=ct1, lty = 2, lwd = 2, col = \"grey20\")\n    \n    \n      ct02  <- tmp4[mx:max(which(!is.na(tmp4[,2]))),]\n      ind02 <- ct02[which(ct02[,2]<c(NA, ct02[-nrow(ct02),2]) & ct02[,2]<c(ct02[-1,2], NA)),1]\n      if(length(ind02)>0) ct2 <- tmp4[ind02[which.min(tmp4[ind02,2])],1] else ct2 <- max(which(!is.na(pr)))\n    # abline(v=ct2, lty = 2, lwd = 2, col = \"grey20\")\n    \n    \n    pr2 <- predict(ls, newdata = ct1:ct2)\n    # lines(ct1:ct2, pr2, lwd=4)\n    \n    ## Data\n    ind3 <- which.max(pr2)\n    \n    ## amp\n    out[i,3] <- diff(range(pr2))\n    \n    ## sd\n    out[i,4] <- sd(pr2)\n    \n    ## Onset\n    onc <- approxfun(x = pr2[1:ind3], y = ct1:(ct1 + (ind3-1)))\n    out[i,1] <- onc(pr2[1] + ((25*(pr2[ind3]-pr2[1]))/100)) \n    # points(out[i,1], pr2[1] + ((25*(pr2[ind3]-pr2[1]))/100), pch = 16, cex = 3, col = \"firebrick\")\n    \n    ## end\n    end <- approxfun(x = pr2[ind3:length(pr2)], y = c(ct1:ct2)[ind3:length(pr2)])\n    out[i,2] <- end(pr2[length(pr2)] + ((25*(pr2[ind3]-pr2[length(pr2)]))/100))\n    # points(out[i,2], pr2[length(pr2)] + ((25*(pr2[ind3]-pr2[length(pr2)]))/100), pch = 16, cex = 3, col = \"firebrick\")\n    \n    # area\n    if(sum(pr2>=50)>1){\n      s <- ifelse((pr2[1] + ((25*(pr2[ind3]-pr2[1]))/100))>50, out[i,1], onc(50))\n      e <- ifelse((pr2[length(pr2)] + ((25*(pr2[ind3]-pr2[length(pr2)]))/100))>50, out[i,2], end(50))\n      pr3 <- c(50, predict(ls, newdata = seq(s, e, by = 1)), 50)\n      x3  <- c(s, seq(s, e, by = 1), e)\n      # polygon(x3, pr3, col=\"red\")\n      out[i, 5] <- areapl(cbind(x3, pr3))\n    }\n    }\n  } # end extraction \n}\n\nndviUSphen <- out \n  colnames(ndviUSphen) <- c(\"start\", \"end\", \"max\", \"sd\", \"area\")\nsave(ndviUSphen, file=\"ndviUSphen.RData\")\nload(\"ndviUSphen.RData\")\n\n\n  rm(NDVI)\nUS <- gIntersection(wrld_simpl, areaSP , byid=T)\n load(\"NDVI_raster.RData\")\ntt <- spTransform(US, CRS(\"+proj=moll +lon_0=-105 +lat_0=0\"))\n  tt1 <- crop(NDVI[[1]], bbox)\n  tt1 <- projectRaster(tt1,crs=\"+proj=moll +lon_0=-105 +lat_0=0\")\n  tt2 <- rasterize(tt, tt1)\n\n\ndur <- NDVI[[1]]\n  dur[] <- ndviUSphen[,2] - ndviUSphen[,1]\n  dur <- crop(dur, bbox)\n  dur <- projectRaster(dur, crs=\"+proj=moll +lon_0=-105 +lat_0=0\")\n  dur[] <- ifelse(tt2[]>0, dur[], NA)\nplot(dur)\n\namp <- NDVI[[1]]\n  amp[] <- ndviUSphen[,3]\n  amp <- crop(amp, bbox)\n  amp <- projectRaster(amp, crs=\"+proj=moll +lon_0=-105 +lat_0=0\")\n  amp[] <- ifelse(tt2[]>0, amp[], NA)\nplot(amp)\n\narea <- NDVI[[1]]\n  area[] <- ndviUSphen[,3]\n  area <- crop(area, bbox)\narea <- projectRaster(area, crs=\"+proj=moll +lon_0=-105 +lat_0=0\")\narea[] <- ifelse(tt2[]>0, area[], NA)\nplot(area)\n\n\n\nsave(amp, file = \"amp_moll.RData\")\nsave(dur, file = \"dur_moll.RData\")\nsave(area, file = \"area_moll.RData\")\n",
    "created" : 1475077746983.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "408280991",
    "id" : "3097BE37",
    "lastKnownWriteTime" : 1392943903,
    "last_content_update" : 1392943903,
    "path" : "~/Documents/GitHub/Lisovski_et_al_20XX/Code/NDVI_DataManipulation.R",
    "project_path" : "Code/NDVI_DataManipulation.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}